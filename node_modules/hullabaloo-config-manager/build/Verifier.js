"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const fs = require("fs");
const path = require("path");
const isEqual = require("lodash.isequal");
const md5Hex = require("md5-hex");
const currentEnv_1 = require("./currentEnv");
const hashDependencies_1 = require("./hashDependencies");
const hashSources_1 = require("./hashSources");
function ensureMissingBabelrcFile(file, cache) {
    if (cache && cache.fileExistence.has(file)) {
        return cache.fileExistence.get(file);
    }
    const promise = new Promise((resolve, reject) => {
        fs.access(file, err => {
            if (err) {
                if (err.code !== 'ENOENT') {
                    reject(err);
                }
                else {
                    resolve(true);
                }
            }
            else {
                resolve(false);
            }
        });
    });
    if (cache) {
        cache.fileExistence.set(file, promise);
    }
    return promise;
}
function checkConfigFiles(babelrcDir, sourcesToHash, cache) {
    return __awaiter(this, void 0, void 0, function* () {
        if (typeof babelrcDir === 'undefined')
            return true;
        const checks = [];
        const babelrcFile = path.join(babelrcDir, '.babelrc');
        if (!sourcesToHash.some(item => item.source === babelrcFile)) {
            checks.push(ensureMissingBabelrcFile(babelrcFile, cache));
        }
        const babelrcJsFile = path.join(babelrcDir, '.babelrc.js');
        if (!sourcesToHash.some(item => item.source === babelrcJsFile)) {
            checks.push(ensureMissingBabelrcFile(babelrcJsFile, cache));
        }
        const results = yield Promise.all(checks);
        return results.every(missing => missing);
    });
}
class Verifier {
    constructor(babelrcDir, envNames, dependencies, sources) {
        this.babelrcDir = babelrcDir;
        this.envNames = envNames;
        this.dependencies = dependencies;
        this.sources = sources;
    }
    static fromBuffer(buffer) {
        const json = JSON.parse(buffer.toString('utf8'), (key, value) => {
            return key === 'envNames' || key === 'envs'
                ? new Set(value)
                : value;
        });
        return new Verifier(json.babelrcDir, json.envNames, json.dependencies, json.sources);
    }
    static hashAndCreate(babelrcDir, envNames, dependencies, sources, fixedSourceHashes, cache) {
        return __awaiter(this, void 0, void 0, function* () {
            const results = yield Promise.all([
                hashDependencies_1.default(dependencies, cache),
                hashSources_1.default(sources, fixedSourceHashes, cache)
            ]);
            const dependencyHashes = results[0];
            dependencies.forEach((item, index) => {
                item.hash = dependencyHashes[index];
            });
            const sourceHashes = results[1];
            sources.forEach((item, index) => {
                item.hash = sourceHashes[index];
            });
            return new Verifier(babelrcDir, envNames, dependencies, sources);
        });
    }
    cacheKeysForEnv(envName) {
        if (typeof envName !== 'string')
            envName = currentEnv_1.default();
        const dependencyHashes = this.selectByEnv(this.dependencies, envName).map(item => item.hash);
        const sourceHashes = this.selectByEnv(this.sources, envName).map(item => item.hash);
        return {
            dependencies: md5Hex(dependencyHashes),
            sources: md5Hex(sourceHashes)
        };
    }
    verifyEnv(envName, fixedHashes, cache) {
        return __awaiter(this, void 0, void 0, function* () {
            if (typeof envName !== 'string')
                envName = currentEnv_1.default();
            const sourcesToHash = this.selectByEnv(this.sources, envName);
            const expectedSourceHashes = sourcesToHash.map(item => item.hash);
            const pendingSourceHashes = hashSources_1.default(sourcesToHash, fixedHashes && fixedHashes.sources, cache);
            const checkedConfigFiles = checkConfigFiles(this.babelrcDir, sourcesToHash, cache);
            const dependenciesToHash = this.selectByEnv(this.dependencies, envName);
            const expectedDependencyHashes = dependenciesToHash.map(item => item.hash);
            const pendingDependencyHashes = hashDependencies_1.default(dependenciesToHash, cache);
            try {
                const results = yield Promise.all([
                    pendingSourceHashes,
                    checkedConfigFiles
                ]);
                const sourceHashes = results[0];
                const configFilesAreSame = results[1];
                if (!configFilesAreSame || !isEqual(sourceHashes, expectedSourceHashes)) {
                    return { sourcesChanged: true };
                }
                const dependencyHashes = yield pendingDependencyHashes;
                const dependenciesChanged = !isEqual(dependencyHashes, expectedDependencyHashes);
                let verifier = this;
                if (dependenciesChanged) {
                    const dependencies = this.dependencies.map(item => {
                        const rehashedIndex = dependenciesToHash.indexOf(item);
                        if (rehashedIndex === -1)
                            return Object.assign({}, item);
                        const hash = dependencyHashes[rehashedIndex];
                        return Object.assign({}, item, { hash });
                    });
                    verifier = new Verifier(this.babelrcDir, this.envNames, dependencies, this.sources);
                }
                return {
                    sourcesChanged: false,
                    dependenciesChanged,
                    cacheKeys: {
                        dependencies: md5Hex(dependencyHashes),
                        sources: md5Hex(sourceHashes)
                    },
                    verifier
                };
            }
            catch (err) {
                if (err.name === 'NoSourceFileError') {
                    return { missingSource: true };
                }
                if (err.name === 'BadDependencyError') {
                    return { badDependency: true };
                }
                throw err;
            }
        });
    }
    toBuffer() {
        return Buffer.from(JSON.stringify({
            babelrcDir: this.babelrcDir,
            envNames: this.envNames,
            dependencies: this.dependencies,
            sources: this.sources
        }, (key, value) => {
            return key === 'envNames' || key === 'envs'
                ? Array.from(value)
                : value;
        }, 2));
    }
    selectByEnv(arr, envName) {
        const selectDefault = !this.envNames.has(envName);
        return arr.filter(item => selectDefault ? item.default : item.envs.has(envName));
    }
}
exports.default = Verifier;
//# sourceMappingURL=Verifier.js.map