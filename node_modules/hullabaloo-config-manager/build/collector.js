"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const path = require("path");
const json5 = require("json5");
const resolveFrom = require("resolve-from");
const Cache_1 = require("./Cache");
const cloneOptions_1 = require("./cloneOptions");
const currentEnv_1 = require("./currentEnv");
const errors_1 = require("./errors");
const loadConfigModule_1 = require("./loadConfigModule");
const SimulatedBabelCache_1 = require("./SimulatedBabelCache");
const readSafe_1 = require("./readSafe");
function has(obj, key) {
    return Object.prototype.hasOwnProperty.call(obj, key);
}
function validateOptions(source, options) {
    if (!options)
        throw new errors_1.InvalidFileError(source, 'Options must be an object');
    if (typeof options !== 'object')
        throw new errors_1.InvalidFileError(source, 'Options must be an object');
    if (Array.isArray(options))
        throw new errors_1.InvalidFileError(source, 'Options must be an object and not an array');
    // See https://github.com/babel/babel/blob/509dbb7302ee15d0243118afc09dde56b2987c38/packages/babel-core/src/config/options.js#L251:L255
    if (has(options, 'sourceMap') && has(options, 'sourceMaps')) {
        throw new errors_1.InvalidFileError(source, '.sourceMap is an alias for .sourceMaps, cannot use both');
    }
    // See https://github.com/babel/babel/blob/509dbb7302ee15d0243118afc09dde56b2987c38/packages/babel-core/src/config/options.js#L19:L36
    if (has(options, 'cwd'))
        throw new errors_1.InvalidFileError(source, '.cwd cannot be used here');
    if (has(options, 'filename'))
        throw new errors_1.InvalidFileError(source, '.filename cannot be used here');
    if (has(options, 'filenameRelative'))
        throw new errors_1.InvalidFileError(source, '.filenameRelative cannot be used here');
    if (has(options, 'babelrc'))
        throw new errors_1.InvalidFileError(source, '.babelrc cannot be used here');
    if (has(options, 'code'))
        throw new errors_1.InvalidFileError(source, '.code cannot be used here');
    if (has(options, 'ast'))
        throw new errors_1.InvalidFileError(source, '.ast cannot be used here');
    if (has(options, 'envName'))
        throw new errors_1.InvalidFileError(source, '.envName cannot be used here');
    if (has(options, 'env')) {
        for (const envName in options.env) {
            // See https://github.com/babel/babel/blob/509dbb7302ee15d0243118afc09dde56b2987c38/packages/babel-core/src/config/options.js#L216:L218
            if (has(options.env[envName], 'env')) {
                throw new errors_1.InvalidFileError(source, '.env is not allowed inside another env block');
            }
            // See https://github.com/babel/babel/blob/2d05487293278286e352d7acc0761751025b4b1a/packages/babel-core/src/config/validation/options.js#L246:L257
            if (has(options.env[envName], 'overrides')) {
                throw new errors_1.InvalidFileError(source, '.overrides is not allowed inside an env block');
            }
        }
    }
    if (has(options, 'overrides')) {
        // See https://github.com/babel/babel/blob/2d05487293278286e352d7acc0761751025b4b1a/packages/babel-core/src/config/validation/options.js#L304
        if (options.overrides !== null && options.overrides !== undefined && !Array.isArray(options.overrides)) {
            throw new errors_1.InvalidFileError(source, '.overrides must be an array');
        }
        for (const override of options.overrides) {
            // See https://github.com/babel/babel/blob/2d05487293278286e352d7acc0761751025b4b1a/packages/babel-core/src/config/config-chain.js#L257:L258
            if (!override)
                throw new errors_1.InvalidFileError(source, `.overrides must only contain objects`);
            // See https://github.com/babel/babel/blob/2d05487293278286e352d7acc0761751025b4b1a/packages/babel-core/src/config/validation/options.js#L249:L250
            if (has(override, 'overrides'))
                throw new errors_1.InvalidFileError(source, '.override is not allowed inside an overrides block');
        }
    }
    return options;
}
function parseFile(source, buffer) {
    let options;
    try {
        options = json5.parse(buffer.toString('utf8'));
    }
    catch (err) {
        throw new errors_1.ParseError(source, err);
    }
    return validateOptions(source, options);
}
function parsePackage(source, buffer) {
    let options;
    try {
        const pkg = JSON.parse(buffer.toString('utf8'));
        // Babel assumes `pkg` is not `undefined` or `null`, and crashes otherwise.
        // This logic is slightly more forgiving but that shouldn't make a read
        // difference.
        if (!pkg || typeof pkg !== 'object' || !has(pkg, 'babel') || !pkg.babel)
            return null;
        options = pkg.babel;
    }
    catch (err) {
        throw new errors_1.ParseError(source, err);
    }
    return validateOptions(source, options);
}
function cloneCachedModule(obj) {
    return Object.assign({}, obj, { runtimeDependencies: new Map(obj.runtimeDependencies), options: cloneOptions_1.default(obj.options) });
}
function resolveModule(source, envName, cache) {
    if (cache && cache.moduleSources.has(source)) {
        const cached = cache.moduleSources.get(source);
        if (Cache_1.isUnrestrictedModuleSource(cached))
            return cloneCachedModule(cached);
        if (cached.byEnv.has(envName))
            return Object.assign({}, cloneCachedModule(cached.byEnv.get(envName)), { factory: cached.factory });
        const result = cached.factory(envName);
        cached.byEnv.set(envName, cloneCachedModule(result));
        return Object.assign({}, result, { factory: cached.factory });
    }
    if (resolveFrom.silent(path.dirname(source), source) === null)
        return null;
    let configModule;
    try {
        configModule = loadConfigModule_1.default(source);
    }
    catch (err) {
        throw new errors_1.ParseError(source, err);
    }
    const dependencies = configModule.dependencies;
    const options = configModule.options;
    if (typeof options !== 'function') {
        if (options && typeof options.then === 'function') {
            throw new errors_1.InvalidFileError(source, 'Asynchronous configuration modules are not supported');
        }
        const validOptions = validateOptions(source, options);
        const result = {
            options: validOptions,
            runtimeDependencies: dependencies,
            runtimeHash: null,
            unrestricted: true
        };
        if (cache)
            cache.moduleSources.set(source, cloneCachedModule(result));
        return cloneCachedModule(result);
    }
    const staticDependencies = Array.from(dependencies);
    dependencies.clear();
    const factory = (envName) => {
        let unrestricted = true;
        const babelCache = new SimulatedBabelCache_1.default({ envName });
        let factoryDependencies;
        let possibleOptions = null;
        try {
            dependencies.clear();
            possibleOptions = options({
                cache: babelCache.api,
                env: () => {
                    unrestricted = false;
                    return babelCache.api.using(data => data.envName);
                },
                async() {
                    /* istanbul ignore next */
                    return false;
                }
            });
        }
        catch (err) {
            throw new errors_1.ParseError(source, err);
        }
        finally {
            factoryDependencies = Array.from(dependencies);
            dependencies.clear();
        }
        babelCache.seal();
        if (!babelCache.wasConfigured)
            throw new errors_1.InvalidFileError(source, 'Caching must be configured');
        if (possibleOptions && typeof possibleOptions.then === 'function') {
            throw new errors_1.InvalidFileError(source, 'Asynchronous configuration modules are not supported');
        }
        return {
            options: validateOptions(source, possibleOptions),
            runtimeDependencies: new Map(staticDependencies.concat(factoryDependencies)),
            runtimeHash: babelCache.hash(),
            unrestricted: unrestricted && !babelCache.never
        };
    };
    const result = factory(envName);
    if (cache) {
        if (result.unrestricted)
            cache.moduleSources.set(source, cloneCachedModule(result));
        else
            cache.moduleSources.set(source, { byEnv: new Map([[envName, cloneCachedModule(result)]]), factory });
    }
    return Object.assign({}, cloneCachedModule(result), { factory });
}
class Config {
    constructor(dir, envName, hash, options, source, fileType, runtimeDependencies, runtimeHash) {
        this.dir = dir;
        this.envName = envName;
        this.fileType = fileType;
        this.hash = hash;
        this.options = options;
        this.runtimeDependencies = runtimeDependencies;
        this.runtimeHash = typeof runtimeHash === 'string' ? runtimeHash : null;
        this.source = source;
        this.babelrcPointer = null;
        this.envPointers = new Map();
        this.extends = null;
        this.extendsPointer = null;
        this.overridePointers = [];
    }
    copyAsOverride(index, options) {
        return new OverrideConfig(index, this.dir, this.envName, this.hash, options, this.source, this.fileType, null, null);
    }
    copyWithEnv(envName, options, runtimeDependencies, runtimeHash) {
        return new Config(this.dir, envName, this.hash, options, this.source, this.fileType, runtimeDependencies, runtimeHash);
    }
    extend(config) {
        const clause = this.takeExtends();
        if (clause) {
            throw new TypeError(`Cannot extend config: there is an extends clause in the current options: ${clause}`);
        }
        if (this.extends) {
            throw new Error('Cannot extend config: already extended');
        }
        this.extends = config;
    }
    takeEnvs() {
        const env = this.options.env;
        delete this.options.env;
        if (!env)
            return new Map();
        const take = Object.keys(env).map(name => [name, env[name]]);
        return new Map(take);
    }
    takeExtends() {
        const clause = this.options.extends;
        delete this.options.extends;
        return clause;
    }
    takeOverrides() {
        const overrides = this.options.overrides;
        delete this.options.overrides;
        return Array.isArray(overrides) ? overrides : [];
    }
}
exports.Config = Config;
class FactoryConfig extends Config {
    constructor(// eslint-disable-line typescript/member-ordering
    dir, source, factory) {
        super(dir, null, null, {}, source, "JS" /* JS */, null, null);
        this.factory = factory;
    }
    copyRestricted(options, runtimeDependencies, runtimeHash) {
        return new RestrictedConfig(this.dir, this.envName, this.hash, options, this.source, this.fileType, runtimeDependencies, runtimeHash);
    }
}
class OverrideConfig extends Config {
    constructor(index, dir, envName, hash, options, source, fileType, runtimeDependencies, runtimeHash) {
        super(dir, envName, hash, options, source, fileType, null, null);
        this.index = index;
    }
    copyWithEnv(envName, options, runtimeDependencies, runtimeHash) {
        const test = this.options.test;
        const include = this.options.include;
        const exclude = this.options.exclude;
        return new OverrideConfig(this.index, this.dir, envName, this.hash, Object.assign({ test, include, exclude }, options), this.source, this.fileType, runtimeDependencies, runtimeHash);
    }
}
exports.OverrideConfig = OverrideConfig;
class VirtualConfig extends Config {
}
exports.VirtualConfig = VirtualConfig;
class RestrictedConfig extends Config {
}
exports.RestrictedConfig = RestrictedConfig;
function resolveDirectory(dir, expectedEnvNames, cache) {
    return __awaiter(this, void 0, void 0, function* () {
        const fileSource = path.resolve(dir, '.babelrc');
        const jsSource = path.resolve(dir, '.babelrc.js');
        const packageSource = path.resolve(dir, 'package.json');
        // Attempt to read file and package concurrently. Neither may exist, and
        // that's OK.
        const fromFile = readSafe_1.default(fileSource, cache);
        const fromPackage = readSafe_1.default(packageSource, cache);
        // Also try to resolve the .babelrc.js file.
        const envName = expectedEnvNames.length > 0
            ? expectedEnvNames[0]
            : currentEnv_1.default();
        const jsOptions = resolveModule(jsSource, envName, cache);
        const fileContents = yield fromFile;
        if (fileContents) {
            const packageContents = yield fromPackage;
            if (packageContents && parsePackage(packageSource, packageContents) !== null) {
                throw new errors_1.MultipleSourcesError(fileSource, packageSource);
            }
            if (jsOptions) {
                throw new errors_1.MultipleSourcesError(fileSource, jsSource);
            }
            return new Config(dir, null, null, parseFile(fileSource, fileContents), fileSource, "JSON5" /* JSON5 */, null, null);
        }
        const packageContents = yield fromPackage;
        if (packageContents) {
            const options = parsePackage(packageSource, packageContents);
            if (options) {
                if (jsOptions)
                    throw new errors_1.MultipleSourcesError(jsSource, packageSource);
                return new Config(dir, null, null, options, packageSource, "JSON" /* JSON */, null, null);
            }
        }
        if (jsOptions) {
            if (jsOptions.unrestricted) {
                return new Config(dir, null, null, jsOptions.options, jsSource, "JS" /* JS */, jsOptions.runtimeDependencies, jsOptions.runtimeHash);
            }
            else if (expectedEnvNames.length === 0) {
                return new Config(dir, envName, null, jsOptions.options, jsSource, "JS" /* JS */, jsOptions.runtimeDependencies, jsOptions.runtimeHash);
            }
            else {
                return new FactoryConfig(dir, jsSource, jsOptions.factory);
            }
        }
        return null;
    });
}
function resolveFile(source, expectedEnvNames, cache) {
    return __awaiter(this, void 0, void 0, function* () {
        const dir = path.dirname(source);
        if (path.extname(source) === '.js') {
            const envName = expectedEnvNames.length > 0
                ? expectedEnvNames[0]
                : currentEnv_1.default();
            const jsOptions = resolveModule(source, envName, cache);
            // The file *must* exist. `resolveModule()` returns `null` when it doesn't.
            // Causes a proper error to be propagated to where "extends" directives are
            // resolved.
            if (!jsOptions)
                throw new errors_1.NoSourceFileError(source);
            if (jsOptions.unrestricted) {
                return new Config(dir, null, null, jsOptions.options, source, "JS" /* JS */, jsOptions.runtimeDependencies, jsOptions.runtimeHash);
            }
            else if (expectedEnvNames.length === 0) {
                return new Config(dir, envName, null, jsOptions.options, source, "JS" /* JS */, jsOptions.runtimeDependencies, jsOptions.runtimeHash);
            }
            else {
                return new FactoryConfig(dir, source, jsOptions.factory);
            }
        }
        const contents = yield readSafe_1.default(source, cache);
        // The file *must* exist. Causes a proper error to be propagated to where
        // "extends" directives are resolved.
        if (!contents)
            throw new errors_1.NoSourceFileError(source);
        return new Config(path.dirname(source), null, null, parseFile(source, contents), source, "JSON5" /* JSON5 */, null, null);
    });
}
class Chains {
    constructor(babelrcDir, defaultChain, envChains) {
        this.babelrcDir = babelrcDir;
        this.defaultChain = defaultChain;
        this.envChains = envChains;
    }
    *[Symbol.iterator]() {
        yield this.defaultChain;
        for (const chain of this.envChains.values()) {
            yield chain;
        }
    }
}
exports.Chains = Chains;
// Configs that came from an env-restricted factory, or "env" or "overrides"
// directives share their source with their parent config, and thus cannot reuse
// the pointer.
function reusePointer(config) {
    return !config.envName && !(config instanceof OverrideConfig) && !(config instanceof RestrictedConfig);
}
class Collector {
    constructor(cache) {
        this.cache = cache;
        this.configs = [];
        this.envNames = new Set();
        this.pointers = new Map();
    }
    get initialConfig() {
        return this.configs[0];
    }
    add(config, expectedEnvNames) {
        return __awaiter(this, void 0, void 0, function* () {
            // Avoid adding duplicate configs.
            if (reusePointer(config) && this.pointers.has(config.source)) {
                return this.pointers.get(config.source);
            }
            const pointer = this.configs.push(config) - 1;
            // Make sure not to override the pointer to an environmental or override
            // config's parent.
            if (reusePointer(config)) {
                this.pointers.set(config.source, pointer);
            }
            if (this.cache && config instanceof VirtualConfig && config.fileType === "JS" /* JS */) {
                this.cache.moduleSources.set(config.source, {
                    options: cloneOptions_1.default(config.options),
                    runtimeDependencies: new Map(),
                    runtimeHash: null,
                    unrestricted: true
                });
            }
            // Collect promises so they can run concurrently and be awaited at the end
            // of this function.
            const waitFor = [];
            if (config instanceof FactoryConfig) {
                for (const envName of expectedEnvNames) {
                    this.envNames.add(envName);
                    let options;
                    let runtimeDependencies = null;
                    let runtimeHash = null;
                    if (this.cache && this.cache.moduleSources.has(config.source)) {
                        // `config` shouldn't be a `FactoryConfig` unless its cached source
                        // is an `EnvModuleSource`.
                        const cached = this.cache.moduleSources.get(config.source);
                        if (cached.byEnv.has(envName)) {
                            options = cloneOptions_1.default(cached.byEnv.get(envName).options);
                        }
                        else {
                            const result = config.factory(envName);
                            cached.byEnv.set(envName, result);
                            options = cloneOptions_1.default(result.options);
                            runtimeDependencies = result.runtimeDependencies;
                            runtimeHash = result.runtimeHash;
                        }
                    }
                    else {
                        const result = config.factory(envName);
                        options = result.options;
                        runtimeDependencies = result.runtimeDependencies;
                        runtimeHash = result.runtimeHash;
                    }
                    const promise = this.add(config.copyRestricted(options, runtimeDependencies, runtimeHash), [envName])
                        .then(envPointer => {
                        config.envPointers.set(envName, envPointer);
                    });
                    waitFor.push(promise);
                }
            }
            else {
                const envs = config.takeEnvs();
                const extendsClause = config.takeExtends();
                const overrides = config.takeOverrides();
                if (config.extends) {
                    const promise = this.add(config.extends, expectedEnvNames).then(extendsPointer => {
                        config.extendsPointer = extendsPointer;
                    });
                    waitFor.push(promise);
                }
                else if (extendsClause) {
                    const extendsSource = path.resolve(config.dir, extendsClause);
                    if (this.pointers.has(extendsSource)) {
                        // Point at existing config.
                        config.extendsPointer = this.pointers.get(extendsSource);
                    }
                    else {
                        // Different configs may concurrently resolve the same extends source.
                        // While only one such resolution is added to the config list, this
                        // does lead to extra file I/O and parsing. Optimizing this is not
                        // currently considered worthwhile.
                        const promise = resolveFile(extendsSource, expectedEnvNames, this.cache).then((parentConfig) => __awaiter(this, void 0, void 0, function* () {
                            config.extendsPointer = yield this.add(parentConfig, expectedEnvNames);
                        })).catch(err => {
                            if (err.name === 'NoSourceFileError') {
                                throw new errors_1.ExtendsError(config.source, extendsClause, err);
                            }
                            throw err;
                        });
                        waitFor.push(promise);
                    }
                }
                for (const pair of envs) {
                    const envName = pair[0];
                    const options = pair[1];
                    this.envNames.add(envName);
                    const promise = this.add(config.copyWithEnv(envName, options, null, null), [envName]).then(envPointer => {
                        config.envPointers.set(envName, envPointer);
                    });
                    waitFor.push(promise);
                }
                overrides.forEach((options, index) => {
                    const promise = this.add(config.copyAsOverride(index, options), expectedEnvNames).then(overridePointer => {
                        config.overridePointers.push(overridePointer);
                    });
                    waitFor.push(promise);
                });
            }
            yield Promise.all(waitFor);
            return pointer;
        });
    }
    resolveChains(babelrcDir) {
        if (this.configs.length === 0)
            return null;
        // Resolves a config chain, correctly ordering parent configs and recursing
        // through environmental configs, while avoiding cycles and repetitions.
        const resolveChain = (from, envName) => {
            const chain = Object.assign(new Set(), { overrides: [] });
            const knownParents = new Set();
            const addOverrides = (config) => {
                for (const pointer of config.overridePointers) {
                    const overrideConfig = this.configs[pointer];
                    const defaultChain = resolveChain([overrideConfig]);
                    if (typeof envName === 'string') {
                        chain.overrides.push(resolveChain(defaultChain, envName));
                    }
                    else {
                        chain.overrides.push(defaultChain);
                    }
                }
            };
            const addWithEnv = (config) => {
                // Avoid unnecessary work in case the `from` list contains configs that
                // have already been added through an environmental config's parent.
                if (chain.has(config))
                    return;
                chain.add(config);
                addOverrides(config);
                if (config.envPointers.has(envName)) {
                    const pointer = config.envPointers.get(envName);
                    const envConfig = this.configs[pointer];
                    addAfterParents(envConfig);
                }
            };
            const addAfterParents = (config) => {
                // Avoid cycles by ignoring those parents that are already being added.
                if (knownParents.has(config))
                    return;
                knownParents.add(config);
                if (config.babelrcPointer !== null) {
                    const parent = this.configs[config.babelrcPointer];
                    addAfterParents(parent);
                }
                if (config.extendsPointer !== null) {
                    const parent = this.configs[config.extendsPointer];
                    addAfterParents(parent);
                }
                if (envName) {
                    addWithEnv(config);
                }
                else {
                    chain.add(config);
                    addOverrides(config);
                }
            };
            for (const config of from) {
                if (envName) {
                    addWithEnv(config);
                }
                else {
                    addAfterParents(config);
                }
            }
            return chain;
        };
        const deleteFactoryConfigs = (chain) => {
            for (const config of chain) {
                if (config instanceof FactoryConfig)
                    chain.delete(config);
            }
            return chain;
        };
        // Start with the first config. This is either the base config provided
        // to fromConfig(), or the config derived from .babelrc / package.json
        // found in fromDirectory().
        const defaultChain = resolveChain([this.initialConfig]);
        // For each environment, augment the default chain with environmental
        // configs.
        const envChains = new Map(Array.from(this.envNames, (name) => {
            return [name, deleteFactoryConfigs(resolveChain(defaultChain, name))];
        }));
        return new Chains(babelrcDir, deleteFactoryConfigs(defaultChain), envChains);
    }
}
function fromConfig(baseConfig, expectedEnvNames, cache) {
    return __awaiter(this, void 0, void 0, function* () {
        let babelrcConfig = null;
        for (let config = baseConfig; config; config = config.extends) {
            if (config.options.babelrc === false)
                continue;
            if (babelrcConfig) {
                throw new TypeError(`${config.source}: Cannot resolve babelrc option, already resolved by ${babelrcConfig.source}`);
            }
            babelrcConfig = config;
        }
        const collector = new Collector(cache);
        yield Promise.all([
            collector.add(baseConfig, expectedEnvNames || []),
            // Resolve the directory concurrently. Assumes that in the common case,
            // the babelrcConfig doesn't extend from a .babelrc file while also leaving
            // the babelrc option enabled. Worst case the resolved config is discarded
            // as a duplicate.
            babelrcConfig && resolveDirectory(babelrcConfig.dir, expectedEnvNames || [], cache).then((parentConfig) => __awaiter(this, void 0, void 0, function* () {
                if (parentConfig) {
                    babelrcConfig.babelrcPointer = yield collector.add(parentConfig, expectedEnvNames || []);
                }
            }))
        ]);
        return babelrcConfig ? collector.resolveChains(babelrcConfig.dir) : collector.resolveChains();
    });
}
exports.fromConfig = fromConfig;
function fromDirectory(dir, expectedEnvNames, cache) {
    dir = path.resolve(dir);
    const collector = new Collector(cache);
    return resolveDirectory(dir, expectedEnvNames || [], cache)
        .then(config => config && collector.add(config, expectedEnvNames || []))
        .then(() => collector.resolveChains(dir));
}
exports.fromDirectory = fromDirectory;
//# sourceMappingURL=collector.js.map