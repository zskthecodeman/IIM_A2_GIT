"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const merge = require("lodash.merge");
const pkgDir = require("pkg-dir");
const cloneOptions_1 = require("./cloneOptions");
const collector_1 = require("./collector");
const errors_1 = require("./errors");
const getPluginOrPresetName_1 = require("./getPluginOrPresetName");
const isFilePath_1 = require("./isFilePath");
const mergePluginsOrPresets_1 = require("./mergePluginsOrPresets");
const normalizeOptions_1 = require("./normalizeOptions");
// FIXME: Remove ESLint exception. Entry *is* used but this isn't being detected.
// eslint-disable-next-line no-unused-vars
const resolvePluginsAndPresets_1 = require("./resolvePluginsAndPresets");
function trackDependency(dependencyMap, filename, fromPackage, envName) {
    if (dependencyMap.has(filename)) {
        const existing = dependencyMap.get(filename);
        if (envName) {
            existing.envs.add(envName);
        }
        else {
            existing.default = true;
        }
        return;
    }
    dependencyMap.set(filename, {
        default: !envName,
        envs: envName ? new Set([envName]) : new Set(),
        filename,
        fromPackage
    });
}
function trackSource(sourceMap, source, runtimeHash, envName) {
    if (sourceMap.has(source)) {
        const existing = sourceMap.get(source);
        if (envName) {
            existing.envs.add(envName);
        }
        else {
            existing.default = true;
        }
        return;
    }
    sourceMap.set(source, {
        default: !envName,
        envs: new Set(envName ? [envName] : []),
        runtimeHash,
        source
    });
}
function mapPluginOrPresetTarget(envName, dependencyMap, getEntry, target) {
    const entry = getEntry(target);
    trackDependency(dependencyMap, entry.filename, entry.fromPackage, envName);
    return entry.filename;
}
function isFileDescriptor(descriptor) {
    return 'filename' in descriptor;
}
exports.isFileDescriptor = isFileDescriptor;
function describePluginOrPreset(dirname, envName, dependencyMap, nameMap, getEntry, item) {
    if (Array.isArray(item)) {
        const target = item[0];
        if (typeof target !== 'string') {
            const name = getPluginOrPresetName_1.default(nameMap, target);
            switch (item.length) {
                case 1: return { dirname, target, name };
                case 2: return { dirname, target, options: item[1], name };
                default: return { dirname, target, options: item[1], name: `${name}.${item[2]}` };
            }
        }
        const filename = mapPluginOrPresetTarget(envName, dependencyMap, getEntry, target);
        const name = getPluginOrPresetName_1.default(nameMap, filename);
        switch (item.length) {
            case 1: return { dirname, filename, name };
            case 2: return { dirname, filename, options: item[1], name };
            default: return { dirname, filename, options: item[1], name: `${name}.${item[2]}` };
        }
    }
    if (typeof item === 'string') {
        const filename = mapPluginOrPresetTarget(envName, dependencyMap, getEntry, item);
        return { dirname, filename, name: getPluginOrPresetName_1.default(nameMap, filename) };
    }
    return { dirname, target: item, name: getPluginOrPresetName_1.default(nameMap, item) };
}
function describePlugin(dirname, envName, dependencyMap, nameMap, resolutions, item) {
    return describePluginOrPreset(dirname, envName, dependencyMap, nameMap, (ref) => resolutions.plugins.get(ref), item);
}
function describePreset(dirname, envName, dependencyMap, nameMap, resolutions, item) {
    const descriptor = describePluginOrPreset(dirname, envName, dependencyMap, nameMap, (ref) => resolutions.presets.get(ref), item);
    if (!isFileDescriptor(descriptor) && typeof descriptor.target === 'object') {
        const target = Object.assign({}, descriptor.target);
        if (Array.isArray(target.plugins)) {
            target.plugins = target.plugins.map(plugin => describePlugin(dirname, envName, dependencyMap, nameMap, resolutions, plugin));
        }
        if (Array.isArray(target.presets)) {
            target.presets = target.presets.map(preset => describePreset(dirname, envName, dependencyMap, nameMap, resolutions, preset));
        }
        descriptor.target = target;
    }
    return descriptor;
}
function isModuleConfig(object) {
    return object.fileType === "JS" /* JS */;
}
exports.isModuleConfig = isModuleConfig;
function mergeChain(chain, envName, pluginsAndPresets, dependencyMap, nameMap, sourceMap, fixedSourceHashes) {
    const list = Object.assign([], { overrides: [] });
    let tail = null;
    const queue = Array.from(chain, (config, index) => {
        const options = cloneOptions_1.default(config.options);
        const overrideIndex = config instanceof collector_1.OverrideConfig
            ? config.index
            : undefined;
        const plugins = options.plugins;
        const presets = options.presets;
        delete options.plugins;
        delete options.presets;
        return {
            config,
            // The first config's options are not normalized.
            options: (index === 0 ? options : normalizeOptions_1.default(options)),
            plugins: Array.isArray(plugins) ? plugins : [],
            presets: Array.isArray(presets) ? presets : [],
            overrideIndex
        };
    });
    for (const item of queue) {
        const config = item.config;
        trackSource(sourceMap, config.source, config.runtimeHash, envName);
        if (config.runtimeDependencies) {
            for (const dependency of config.runtimeDependencies) {
                const filename = dependency[0];
                const fromPackage = isFilePath_1.default(dependency[1]) ? null : pkgDir.sync(filename);
                trackDependency(dependencyMap, filename, fromPackage, envName);
            }
        }
        if (config.hash !== null) {
            fixedSourceHashes.set(config.source, config.hash);
        }
        // When used properly, pluginsAndPresets *will* contain a lookup for
        // `config`. Don't handle situations where this is not the case. This is an
        // internal module after all.
        const resolutionMap = pluginsAndPresets.get(config);
        const plugins = item.plugins.map(plugin => {
            return describePlugin(config.dir, envName, dependencyMap, nameMap, resolutionMap, plugin);
        });
        const presets = item.presets.map(preset => {
            return describePreset(config.dir, envName, dependencyMap, nameMap, resolutionMap, preset);
        });
        if (plugins.length !== new Set(plugins.map(plugin => plugin.name)).size) {
            throw new errors_1.InvalidFileError(config.source, 'Duplicate plugins detected');
        }
        if (presets.length !== new Set(presets.map(preset => preset.name)).size) {
            throw new errors_1.InvalidFileError(config.source, 'Duplicate presets detected');
        }
        if (config.fileType === "JS" /* JS */) {
            // Note that preparing `plugins` and `presets` has added them to
            // `dependencyMap`. This will still be used when determining the
            // configuration hash, even if the values are discarded.
            const moduleConfig = {
                dir: config.dir,
                envName: config.envName,
                fileType: config.fileType,
                source: config.source
            };
            if (item.overrideIndex !== undefined) {
                moduleConfig.overrideIndex = item.overrideIndex;
            }
            list.push(moduleConfig);
            tail = null;
        }
        else if (tail && item.overrideIndex === tail.overrideIndex) {
            mergePluginsOrPresets_1.default(tail.options.plugins, plugins);
            mergePluginsOrPresets_1.default(tail.options.presets, presets);
            merge(tail.options, item.options);
            if (tail.fileType === "JSON" /* JSON */ && config.fileType === "JSON5" /* JSON5 */) {
                tail.fileType = config.fileType;
            }
        }
        else {
            item.options.plugins = plugins;
            item.options.presets = presets;
            tail = {
                fileType: config.fileType,
                options: item.options
            };
            if (item.overrideIndex !== undefined) {
                tail.overrideIndex = item.overrideIndex;
            }
            list.push(tail);
        }
    }
    for (const overrideChain of chain.overrides) {
        const merged = mergeChain(overrideChain, envName, pluginsAndPresets, dependencyMap, nameMap, sourceMap, fixedSourceHashes);
        for (const recursive of merged.overrides) {
            list.overrides.push(recursive);
        }
        list.overrides.push(merged.slice());
    }
    return list;
}
function sortKeys(a, b) {
    return a[0] < b[0] ? -1 : 1;
}
function reduceChains(chains, cache) {
    const pluginsAndPresets = resolvePluginsAndPresets_1.default(chains, cache);
    const dependencyMap = new Map();
    const nameMap = cache ? cache.nameMap : new Map();
    const envNames = new Set();
    const fixedSourceHashes = new Map();
    const sourceMap = new Map();
    const unflattenedDefaultOptions = mergeChain(chains.defaultChain, null, pluginsAndPresets, dependencyMap, nameMap, sourceMap, fixedSourceHashes);
    const unflattenedEnvOptions = new Map();
    for (const pair of chains.envChains) {
        const envName = pair[0];
        const chain = pair[1];
        envNames.add(envName);
        unflattenedEnvOptions.set(envName, mergeChain(chain, envName, pluginsAndPresets, dependencyMap, nameMap, sourceMap, fixedSourceHashes));
    }
    const dependencies = Array.from(dependencyMap).sort(sortKeys).map(entry => entry[1]);
    const sources = Array.from(sourceMap).sort(sortKeys).map(entry => entry[1]);
    return {
        dependencies,
        envNames,
        fixedSourceHashes,
        sources,
        unflattenedDefaultOptions,
        unflattenedEnvOptions
    };
}
exports.default = reduceChains;
//# sourceMappingURL=reduceChains.js.map