"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const merge = require("lodash.merge");
const resolveFrom = require("resolve-from");
const Cache_1 = require("./Cache");
const cloneOptions_1 = require("./cloneOptions");
const errors_1 = require("./errors");
const reduceChains_1 = require("./reduceChains");
const getPluginOrPresetName_1 = require("./getPluginOrPresetName");
const loadPluginOrPreset_1 = require("./loadPluginOrPreset");
const mergePluginsOrPresets_1 = require("./mergePluginsOrPresets");
const normalizeOptions_1 = require("./normalizeOptions");
const standardizeName_1 = require("./standardizeName");
// Called for plugins and presets found when loading cached configuration modules.
function resolvePluginOrPreset(source, resolutionCache, kind, ref) {
    const name = standardizeName_1.default(kind, ref).name;
    if (!resolutionCache.has(name))
        throw new errors_1.ResolveFromCacheError(source, kind, ref);
    return resolutionCache.get(name);
}
// Called for plugins and presets found at runtime in preset objects.
function resolveDynamicPluginOrPreset(kind, dirname, ref) {
    const name = standardizeName_1.default(kind, ref).name;
    const filename = resolveFrom(dirname, name);
    return loadPluginOrPreset_1.default(filename);
}
function describePluginOrPreset(dirname, source, resolutionCache, nameMap, item, kind) {
    if (Array.isArray(item)) {
        const target = item[0];
        if (typeof target !== 'string') {
            const name = getPluginOrPresetName_1.default(nameMap, target);
            switch (item.length) {
                case 1: return { dirname, target, name };
                case 2: return { dirname, target, options: item[1], name };
                default: return { dirname, target, options: item[1], name: `${name}.${item[2]}` };
            }
        }
        const filename = resolvePluginOrPreset(source, resolutionCache, kind, target);
        const name = getPluginOrPresetName_1.default(nameMap, filename);
        switch (item.length) {
            case 1: return { dirname, filename, name };
            case 2: return { dirname, filename, options: item[1], name };
            default: return { dirname, filename, options: item[1], name: `${name}.${item[2]}` };
        }
    }
    if (typeof item === 'string') {
        const filename = resolvePluginOrPreset(source, resolutionCache, kind, item);
        return { dirname, filename, name: getPluginOrPresetName_1.default(nameMap, filename) };
    }
    return { dirname, target: item, name: getPluginOrPresetName_1.default(nameMap, item) };
}
// Rewrite plugins from cached configuration modules to match those from regular
// configuration files.
function describePlugin(dirname, source, resolutionCache, nameMap, item) {
    return describePluginOrPreset(dirname, source, resolutionCache, nameMap, item, "plugin" /* PLUGIN */);
}
// Rewrite presets from cached configuration modules to match those from regular
// configuration files.
function describePreset(dirname, source, resolutionCache, nameMap, item) {
    const descriptor = describePluginOrPreset(dirname, source, resolutionCache, nameMap, item, "preset" /* PRESET */);
    if (!reduceChains_1.isFileDescriptor(descriptor) && typeof descriptor.target === 'object') {
        const target = Object.assign({}, descriptor.target);
        if (Array.isArray(target.plugins)) {
            target.plugins = target.plugins.map(plugin => describePlugin(dirname, source, resolutionCache, nameMap, plugin));
        }
        if (Array.isArray(target.presets)) {
            target.presets = target.presets.map(preset => describePreset(dirname, source, resolutionCache, nameMap, preset));
        }
        descriptor.target = target;
    }
    return descriptor;
}
function arrifyPluginsOrPresets(list, wrapperFnsByDir, rewrite) {
    return list.map(item => {
        let wrapperFns;
        if (wrapperFnsByDir.has(item.dirname)) {
            wrapperFns = wrapperFnsByDir.get(item.dirname);
        }
        else {
            wrapperFns = new Map();
            wrapperFnsByDir.set(item.dirname, wrapperFns);
        }
        let target;
        if (!reduceChains_1.isFileDescriptor(item) && typeof item.target === 'object') {
            target = item.target;
        }
        else if (wrapperFns.has(item.name)) {
            target = wrapperFns.get(item.name);
        }
        else {
            const wrapped = reduceChains_1.isFileDescriptor(item) ? loadPluginOrPreset_1.default(item.filename) : item.target;
            const targetFn = Object.assign(rewrite
                ? (api, options) => rewrite(item.dirname, wrapped(api, options, item.dirname))
                : (api, options) => wrapped(api, options, item.dirname), { wrapped });
            wrapperFns.set(item.name, targetFn);
            target = targetFn;
        }
        return [target, item.options, item.name];
    });
}
// Turn plugin objects back into arrays for use in Babel.
function arrifyPlugins(list, wrapperFnsByDir) {
    return arrifyPluginsOrPresets(list, wrapperFnsByDir);
}
// Rewrite a preset object so its plugins and presets are resolved relative
// to the correct dirname and factories are called with the correct dirname.
function rewritePreset(dirname, obj) {
    // istanbul ignore next
    if (!obj || typeof obj !== 'object')
        return obj;
    obj = Object.assign({}, obj);
    if (Array.isArray(obj.plugins)) {
        const pluginWrapperFns = new Map();
        obj.plugins = obj.plugins.map(plugin => {
            const target = Array.isArray(plugin) ? plugin[0] : plugin;
            if (typeof target === 'object')
                return plugin;
            let targetFn;
            const wrapped = typeof target === 'function' ? target : resolveDynamicPluginOrPreset("plugin" /* PLUGIN */, dirname, target);
            if (pluginWrapperFns.has(wrapped)) {
                targetFn = pluginWrapperFns.get(wrapped);
            }
            else {
                targetFn = Object.assign((api, options) => wrapped(api, options, dirname), { wrapped });
                pluginWrapperFns.set(wrapped, targetFn);
            }
            if (Array.isArray(plugin)) {
                switch (plugin.length) {
                    case 1: return [targetFn];
                    case 2: return [targetFn, plugin[1]];
                    default: return [targetFn, plugin[1], plugin[2]];
                }
            }
            else {
                return targetFn;
            }
        });
    }
    if (Array.isArray(obj.presets)) {
        const presetWrapperFns = new Map();
        obj.presets = obj.presets.map(preset => {
            const target = Array.isArray(preset) ? preset[0] : preset;
            if (typeof target === 'object') {
                const rewritten = rewritePreset(dirname, target);
                if (Array.isArray(preset)) {
                    switch (preset.length) {
                        case 1: return [rewritten];
                        case 2: return [rewritten, preset[1]];
                        default: return [rewritten, preset[1], preset[2]];
                    }
                }
                else {
                    return rewritten;
                }
            }
            let targetFn;
            const wrapped = typeof target === 'function' ? target : resolveDynamicPluginOrPreset("preset" /* PRESET */, dirname, target);
            if (presetWrapperFns.has(wrapped)) {
                targetFn = presetWrapperFns.get(wrapped);
            }
            else {
                targetFn = Object.assign((api, options) => rewritePreset(dirname, wrapped(api, options, dirname)), { wrapped });
                presetWrapperFns.set(wrapped, targetFn);
            }
            if (Array.isArray(preset)) {
                switch (preset.length) {
                    case 1: return [targetFn];
                    case 2: return [targetFn, preset[1]];
                    default: return [targetFn, preset[1], preset[2]];
                }
            }
            else {
                return targetFn;
            }
        });
    }
    return obj;
}
// Turn preset objects back into arrays for use in Babel.
function arrifyPresets(list, wrapperFnsByDir) {
    return arrifyPluginsOrPresets(list, wrapperFnsByDir, rewritePreset).map(preset => {
        const target = preset[0];
        if (typeof target === 'object') {
            const obj = Object.assign({}, target);
            if (Array.isArray(target.plugins)) {
                obj.plugins = arrifyPlugins(target.plugins, wrapperFnsByDir);
            }
            if (Array.isArray(target.presets)) {
                obj.presets = arrifyPresets(target.presets, wrapperFnsByDir);
            }
            preset[0] = obj;
        }
        return preset;
    });
}
function loadCachedModule(cache, dir, source, envName, selectEnv, selectOverride) {
    if (!cache)
        throw new Error(`A cache is required to load the configuration module at '${source}'`);
    const cached = cache.moduleSources.get(source);
    if (!cached)
        throw new Error(`Could not find the configuration module for '${source}' in the cache`);
    if (!Cache_1.isUnrestrictedModuleSource(cached) && !cached.byEnv.has(envName)) {
        throw new Error(`Could not find the configuration module, specific to the '${envName}' environment, for '${source}', in the cache`); // eslint-disable-line max-len
    }
    let options = cloneOptions_1.default(Cache_1.isUnrestrictedModuleSource(cached) ? cached.options : cached.byEnv.get(envName).options);
    if (selectOverride !== undefined)
        options = options.overrides[selectOverride];
    if (selectEnv)
        options = options.env[envName];
    delete options.env;
    delete options.extends;
    delete options.overrides;
    normalizeOptions_1.default(options);
    const resolutionCache = cache.pluginsAndPresets.get(dir);
    if (Array.isArray(options.plugins)) {
        options.plugins = options.plugins.map(item => describePlugin(dir, source, resolutionCache, cache.nameMap, item));
    }
    else {
        options.plugins = [];
    }
    if (Array.isArray(options.presets)) {
        options.presets = options.presets.map(item => describePreset(dir, source, resolutionCache, cache.nameMap, item));
    }
    else {
        options.presets = [];
    }
    // Don't check for duplicate plugin or preset names. Presumably these have
    // been validated when configs were collected.
    return options;
}
exports.loadCachedModule = loadCachedModule;
function mergeOptions(configs, wrapperFnsByDir) {
    const merged = configs.reduce((target, options) => {
        mergePluginsOrPresets_1.default(target.plugins, options.plugins);
        delete options.plugins;
        mergePluginsOrPresets_1.default(target.presets, options.presets);
        delete options.presets;
        return merge(target, options);
    }, { plugins: [], presets: [] });
    const retval = merged;
    if (merged.plugins.length > 0) {
        retval.plugins = arrifyPlugins(merged.plugins, wrapperFnsByDir);
    }
    else {
        delete retval.plugins;
    }
    if (merged.presets.length > 0) {
        retval.presets = arrifyPresets(merged.presets, wrapperFnsByDir);
    }
    else {
        delete retval.presets;
    }
    return retval;
}
exports.mergeOptions = mergeOptions;
//# sourceMappingURL=helpers.js.map