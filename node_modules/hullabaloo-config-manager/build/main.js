"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const path = require("path");
const Cache_1 = require("./Cache");
exports.prepareCache = Cache_1.prepare;
const cloneOptions_1 = require("./cloneOptions");
const collector = require("./collector");
const currentEnv_1 = require("./currentEnv");
exports.currentEnv = currentEnv_1.default;
const ResolvedConfig_1 = require("./ResolvedConfig");
const Verifier_1 = require("./Verifier");
function createConfig(options) {
    if (!options || !options.options || !options.source) {
        throw new TypeError("Expected 'options' and 'source' options");
    }
    if (typeof options.options !== 'object' || Array.isArray(options.options)) {
        throw new TypeError("'options' must be an actual object");
    }
    const source = options.source;
    const dir = options.dir || path.dirname(source);
    const hash = typeof options.hash === 'string' ? options.hash : null;
    const fileType = typeof options.fileType === 'string' ? options.fileType : "JSON5" /* JSON5 */;
    const babelOptions = cloneOptions_1.default(options.options);
    if (Object.prototype.hasOwnProperty.call(babelOptions, 'envName')) {
        throw new TypeError("'options' must not have an 'envName' property");
    }
    return new collector.VirtualConfig(dir, null, hash, babelOptions, source, fileType, null, null);
}
exports.createConfig = createConfig;
function fromConfig(baseConfig, options) {
    return __awaiter(this, void 0, void 0, function* () {
        const cache = options && options.cache;
        const expectedEnvNames = options && options.expectedEnvNames;
        const chains = yield collector.fromConfig(baseConfig, expectedEnvNames, cache);
        return new ResolvedConfig_1.default(chains, cache);
    });
}
exports.fromConfig = fromConfig;
function fromDirectory(dir, options) {
    return __awaiter(this, void 0, void 0, function* () {
        const cache = options && options.cache;
        const expectedEnvNames = options && options.expectedEnvNames;
        const chains = yield collector.fromDirectory(dir, expectedEnvNames, cache);
        return chains && new ResolvedConfig_1.default(chains, cache);
    });
}
exports.fromDirectory = fromDirectory;
function restoreVerifier(buffer) {
    return Verifier_1.default.fromBuffer(buffer);
}
exports.restoreVerifier = restoreVerifier;
//# sourceMappingURL=main.js.map